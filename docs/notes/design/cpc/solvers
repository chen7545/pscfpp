
Problem: 

   How to modify classes in pscf/chem and pscf/solvers to allow
   subclasses to do complex Langevin sampling. This will require
   introduction of type WT and redefining some variables that are
   currently double to WT.

Strategy:

   Input value of phi or mu should still be real

   All internal values of phi or mu should become complex, 
       along with w, c and q fields

Directory pscf/chem:
=====================

   class Monomer (kuhn_ remains real)  - unchanged

   enumeration PolymerType (enumeration) unchanged

   class Edge - unchanged

   class Vertex - unchanged

   class EdgeIterator - unchanged

   class VertexIterator - unchanged

   class Species: Make this a template of type WT, default to double

      - Make member variables q_, phi_, and mu_ type WT

      - Create a new private variable double phiMu_, read this
        in Species::readParameters. The input parameter is real,
        but is converted to WT.
  
        bool hasPhi = readOptional(in, "phi", inputPhiMu_).isActive();
        if (hasPhi) { 
           ensemble = Species::Closed; 
           assign(phi_, phiMu_);
        } else {
           read(in, "mu", inputPhiMu_);
           assign(phi_, phiMu_);
        }

      - Use function template "assign" to assign real input variable
        phiMu_ to either real or complex mu_ and phi_ variables

      - Change setPhi(double phi) and setMu(double Mu) to set
        phiMu_ as well as phi_ or mu_, using assign function

      - Add extern template declaration to Species.h for WT=double

      - Compile double type in pscf/chem/SolventSpecies.cpp

      - Compile complex types in cpc and cpg

   class SolventSpecies: 

      Make this class a template of type WT, default to double.

      No class member variables need to be changed to complex.
      No changes to class implementation appear to be necessary.

      - Add extern template declaration to Species.h for WT=double

      - Compile double types in pscf/chem/SolventSpecies.cpp

      - Compile complex types in cpc/ and cpg/
       
   class PolymerSpecies: 

      Make this class a template of type WT, default to double.

      No class member variables need to be changed to complex.
      No changes to class implementation appear to be necessary.

      - Add extern template declaration to Species.h for WT=double

      - Compile double types in pscf/chem/SolventSpecies.cpp

      - Compile complex types in cpc/ and cpg/

Directory pscf/solver (templates): 
==================================

   template <class TP> class Propagator 
   ------------------------------------

      None of the current private variables of this class template are
      type double, and none need to be generalized to WT

      Require concrete Propagator class to define a single typedef Field


   template <class TP> class BlockTmpl : public Edge
   -------------------------------------------------

      Largely unchanged

      Remove CField, WField typedefs - not needed in template

      Keep Block::Propagator, however, because this is used in PolymerTmpl

      Private member variable (all unchanged):

          Pair<Propagator> propagators_;
          typename Propagator::Field cField;
          double kuhn_;

      typename TP::Field cField_
   
   template <class Block, typename WT = double>
   class PolymerTmpl : public PolymerSpecies<WT>
   ---------------------------------------------------

      Make WT an additional template parameter

      Private member variable:

          DArray<Block> blocks_

      Proposal:
      
           Remove declaration and definition of the solve(double phiTot)
           function and declare and define in subclasses.

           To avoid complete code duplication, we could define templates 
           Prdc::Rl::Polymer and Prdc::Cl::Polymer for real and complex
           valued fields.

      Rationale: Why not define solve() in this template?

          1) The interface currently involves a parameter phiTot that 
          I wouldn't want to propagate into a complex Langevin sampling 
          code. It also really doesn't belong in real 1D code.

          2) The implementation includes a ratio Q = Q/phiTot for 
          which the operator can't be overloaded, forcing different 
          implementations just for this one operation. Admittedly, this
          could be addressed by using a global function for division 
          that is overloaded for different types.

