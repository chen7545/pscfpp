Goals: 
-----

- Convert as much as possible of the code for classes defined in 
rpc/ and rpg/ (namespace Rpc and Rpg) to classes derived from 
instantiations of class templates defined in rp/ (namespace Rp).

- Start with development of templates for Simulator and solver
classes, since these are basic building blocks that need to be
written early in the development of analogous complex Langevin
simulations. For solver classes, Mixture is already templatized,
so work our way down Polymer next, followed by Solvent, then
Propagator. Templatize the Block class last, since this will be
the hardest.

- Using results as a starting point for early development of 
templates for Simulator and solver classes for complex Langevin 
simulations in namespace Cp. As we start to add step and analysis 
algorithms, try to develop these as base class templates from the 
outset, to avoid the need to repeat this process of merging 
definitions of existing classes. 

Steps toward these goals:
-------------------------

1) General: Whenever possible, in Cpu functions, convert to the use
of functions from Cpu::VecOp or Cpu::Reduce in preference to hand 
coded loops for cases in which the analogous Rpg functions use 
functions from Cuda::VecOp or Cuda::Reduce. Add functions to both
Cpu::VecOp and Cuda::VecOp as needed to keep these two libraries
analogous, and allow them to be used as widely as possible. 

2) Functions that require more thought are generally those that use
Cuda kernels and C++ wrapper functions that are implemted either 
within in the VecOpFts files or in the class *.cu file, since these 
are functions that have no analogs in the Rpc namespace.  Seek to 
replace these two types of GPU-accelerated functions with functions 
for which it is possible to define analogous interfaces for use in
Rpc and Rpg versions of code. Strategies for doing this:

    - Define operations using functions from VecOp when possible.
      Consider adding new operations to VecOp when this makes sense
      and solves the problem. 

    - For more specialized functions that cannot easily be expressed 
      in terms of VecOp functions, define private or protected virtual 
      functions in the base class to encapsulate functions that are
      only used in one class but have to be implemented differently 
      in Rpc and Rpg derived classes.

    - When necessary to define , define GPU kernels in anonymous 
      namespaces of .cu files, and use the kernels to implement GPU 
      versions of overriden virtual C++ member functions that are
      needed to implement.

3) Consider adding aliases RealArray and CmplxArray in the Types 
classes defined in the Rpc and Rpg namespaces. In Rpc, these can 
refer to Array<double> and Array<fftw_complex, while in Rpg these 
refer to DeviceArray<cudaReal> and DeviceArray<cudaComplex>. Defining 
these aliases would allow template code to manipulate lower level
array classes, without requiring that they be field classes 
(RField, RFieldDft, or CField) that contain extra information 
about mesh dimensions.

4) Create new CpuVecRandom class with an interface analogous to that
of CudaRandom. Change Cpc::Simulator so as to have both scalar RNG
instance of Util::Random and a vector RNG instance of CpuVecRandom. 
This will remove the most important remaining difference between
interfaces of Rpc::Simulator and Rpg::Simulator.  Add functions to
both CpuVecRandom and CudaRandom that can fill an array of uniformly
distributed random numbers within a range (min, max] other than 
(0,1], for use in some MC algorithms. 

(Possible: Consider changing class name CudaRandom to CudaVecRandom 
for parallelism with CpuVecRandom. In Types class and Rp::Simulator 
template, use a class name alias VecRandom to refer to one or the other 
of these classes interchangeably.)

5) Later, when we start to create templates for BD and MC 
algorithms, switch to use of Simulator::vecRandom() to populate 
arrays of random numbers in BD and MC steps everywhere that 
Cpg::Simulator::CudaRandom is used in analogous GPU code.

Proposals for conversion of functions in VecOpFts :

1) VecOpFts::mcftsScale :  Replace use of this with use of new functions
in CudaRandom and CpuVecRandom that can populate an array with random
numbers in a range [min, max] with min = -b and max = +b. (The required
function now exists)

2) VecOpFts::fourierMove :  Replace this with a new function 
VecOp::addEqV(Array<complex>& , Array<real> const &, Array<real> const &)
that allows the increment vector for a vector increment to be input in
terms of real and imaginary parts (this now exists).

3) VecOpFts::computeDField : It looks like this is equivalent to
addition of two real vectors with coefficients and a scalar. Use a 
new function VecOp::addVcVcS designed to allow construction of a 
linear combination of two vectors and an additive scalar.

4) computeForceBias : This looks more specialized, and appears to
only be used in one class (the force bias MC class). We can define
a private pure virtual function of the MC force bias class with the 
same interface as the kernel wrapper, and then implement versions 
of this funcction in the Rpc and Rpg subclasses, in which the Rpg 
version calls a corresponding CUDA kernel

Proposals for conversion of functions defined in Rpg::Block :

1) Define a pure virtual function realMulVConjVV in Rp::Block base 
class, with an interface analogous to that of the realMulVConjVV
global function defined and used in rpg/solvers/Block.tpp.  Use new 
type aliases CmplxArray and RealArray in the function interface.

2) richardsonEx . Implement this as a pair of VecOp operations,
calling mulEqV(qr2, expW2) followed by a call to 
addVcVc(qr2, 4.0/3.0, qr, -1.0/3.0). Comment: I am guessing that
any saving in time obtained by combining these operations is
insignificant, or not worth the loss in algorithm clarity. 
