Proposal for Intramolecular Omega Functions:

=================================================================
Current arrangement:

   Class Pscf::Debye in directory pscf/chem

   class Pscf::Rpc::IntraOmega in rpc/fts/compressor/intra
   class Pscf::Rpg::IntraOmega in rpg/fts/compressor/intra

   Provide function computeIntraOmegas(RField<D>& correlations),
   in which RField<D> has dimensions IntVec<D> kMeshDimensions_;

=================================================================
Proposed directory and namespace structure:

   pscf/omega
  
   namespace Pscf {
      namespace Omega {
         namespace Debye;
         class Polymer;
         class Mixture;
      }
   }

=================================================================
Thread vs. bead models:

   In Polymer and Mixtures classes, all compute functions will 
   automatically call the correct function from Omega::Debye for 
   the chosen polymer model (bead or thread).  Public interface 
   for these classes will thus not need to distinguish bead and 
   thread models. 

   We can store isThread_ as a private variable of class that
   computes polymer correlation functions.

=================================================================
namespace Pscf {
namespace Omega {

   =================================================================
   class Debye - Unchanged from current version
   
   =================================================================
   class Polymer {
   
      /**
      * Constructor.
      *
      * \param polymer  associated polymer structure descriptor
      */
      PolymerOmega(PolymerSpecies const & polymer);
   
      /**
      * Set q-independent properties.
      *
      * \param kuhnSq  square kuhn values, indexed by monomer type
      */ 
      void initialize(Array<double> const & kuhnSq);
   
      /**
      * Clears q-independent structural properties (rSq_ and bSq_)
      */ 
      void clear();
   
      /**
      * Get pre-computed value of R^2 for path between blocks.
      *
      * \param ib block id
      * \param jb block id
      */
      double rSq(int ib, int jb);
   
      /**
      * Get statistical segment length for a block. 
      *
      * \param ib block id
      */
      double bSq(int ib);
   
      /**
      * Get omega function associated with two blocks.
      *
      * \param ib  block id (in)
      * \param jb  block id (in) 
      * \param kSq  square wavenumber (in)
      * \return  calculated omega value
      */
      double computeOmega(int ib, int jb, double kSq);
   
      /**
      * Set array of omega function for two blocks.
      *
      * \param ib  block id (in)
      * \param jb  block id (in)
      * \param kSq  array of values of square wavenumber (in)
      * \param omega  array of corresponding omega values (out)
      */
      template <class FT>
      void computeOmega(int i, int j, FT const & kSq, FT& omega);
   
   private:
  
      /** 
      * Matrix of values Rsq_ between pairs of blocks.
      */
      DMatrix<double> rSq_;
  
      /** 
      * Array of values of square statistical segment lengths for blocks.
      *
      * Indexed by block index.
      */
      DArray<double> bSq_;
  
      /** 
      * Pointer to associated PolymerSpecies object.
      */
      PolymerSpecies const * polymerPtr_;
  
      /** 
      * Is a continuous thread model in use?
      */
      bool isThread_;
  
      /**
      * True if rSq_, bSq_, and isThread_ are up to date.
      */
      bool isInitialized_;
   
   };
   =================================================================
   
   =================================================================
   class Mixture {
   
      Mixture(MixtureBase const & mixture);
   
      initialize();
   
      clear();
  
      /**
      * Return a child polymer object.
      */ 
      Omega::Polymer & polymer(int i);
  
      /**
      * Compute Omega for monomer types, for one wavenumber.
      *
      * \param im  monomer type index
      * \param jm  monomer type index
      * \param kSq  square wavenumber
      */ 
      double compute(int im, int jm, double kSq);
   
      /**
      * Compute Omega for two monomer types, for a wavenumber array.
      *
      * \param im  monomer type index (in)
      * \param jm  monomer type index (in) 
      * \param kSq  array of square wavenumber values (in)
      * \param kSq  array of Omega values (out)
      */ 
      template <class FT>
      void compute(int im, int jm, FT const & kSq, FT& omega);
   
      /**
      * Compute density-density correlation, for one wavenumber.
      *
      * \param kSq  square wavenumber value
      */ 
      double computeTotal(double kSq);

      /**
      * Compute density-density correlation, for array of wavenumbers.
      *
      * \param kSq  array of square wavenumber values (in)
      * \param kSq  array of Omega values (out)
      */
      template <class FT>
      void computeTotal(FT const & kSq, FT& omega);
   
   private:
   
      // Array of Polymer correlation objects
      DArray<Polymer> polymers_;
   
      // Array of squared statistical segement length values
      DArray<double> kuhnSq_;
   
      // Lists of blocks indexed by monomer type (??)
      DArray< GArray< Pair<int> > > blocks_;
   
      // Lists of solvents indexed by monomer type (??)
      DArray< GArray< solvent > blocks_;
   
   };
   =================================================================

}
}
